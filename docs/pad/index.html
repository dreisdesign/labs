<!DOCTYPE html>
<!-- Last updated: August 26, 2025 at 10:26 AM ET - Fixed CSS import and zoom issues -->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pad V1.0</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#FBFBFD">
  <link rel="stylesheet" href="../design-system/tokens/colors.css">
  <link rel="stylesheet" href="../design-system/styles/flavors.css">
  <script type="module" src="../design-system/components/labs-icon.js"></script>
  <script type="module" src="../design-system/components/labs-button.js"></script>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--color-background, #FBFBFD);
      color: var(--color-on-background, #372116);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .pad-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }


    .pad-theme-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
    }

    .pad-version-badge {
      position: absolute;
      top: 20px;
      right: 70px;
      z-index: 100;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--color-outline, #b0b0b0);
      background: var(--color-surface, #fff8);
      border-radius: 6px;
      padding: 2px 10px;
      letter-spacing: 0.04em;
      user-select: none;
      pointer-events: none;
      box-shadow: 0 1px 2px 0 #0001;
    }

    .pad-clear-button {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 100;
    }

    .pad-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      touch-action: none;
      /* Prevent scrolling/zooming */
    }

    /* Ensure canvas fills entire screen */
    .pad-canvas {
      display: block;
    }

    /* Loading state for better UX */
    .pad-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--color-on-background, #372116);
      opacity: 0.5;
      font-size: 16px;
      display: none;
    }

    /* Add some subtle visual feedback */
    .pad-canvas:active {
      cursor: none;
      /* Hide cursor while drawing */
    }
  </style>
</head>

<body>
  <div class="pad-container">
    <!-- Version badge (top-right, left of theme toggle) -->
    <div class="pad-version-badge">v1.0</div>
    <!-- Theme toggle button (top-right) -->
    <labs-button id="themeToggle" class="pad-theme-toggle" variant="icon" aria-label="Toggle theme">
      <labs-icon id="themeIcon" slot="icon-left" name="bedtime"></labs-icon>
    </labs-button>

    <!-- Clear button (bottom-right) -->
    <labs-button id="clearButton" class="pad-clear-button" variant="icon" aria-label="Clear canvas">
      <labs-icon slot="icon-left" name="delete_forever" color="var(--color-error)"></labs-icon>
    </labs-button>

    <canvas id="drawingCanvas" class="pad-canvas" width="1024" height="768"></canvas>
  </div>

  <script>
    // Theme management utilities
    function applyTheme({ flavor = 'vanilla', theme = 'light' } = {}) {
      const root = document.documentElement;
      root.classList.remove('flavor-vanilla', 'flavor-blueberry', 'flavor-strawberry');
      root.classList.add(`flavor-${flavor}`);
      root.classList.remove('theme-light', 'theme-dark');
      root.classList.add(`theme-${theme}`);
      root.setAttribute('data-color-scheme', theme);
      localStorage.setItem('pad-theme', theme);

      // Update meta theme-color for PWA
      const themeColorMeta = document.querySelector('meta[name="theme-color"]');
      const bgColor = getComputedStyle(root).getPropertyValue('--color-background').trim();
      if (themeColorMeta && bgColor) {
        themeColorMeta.setAttribute('content', bgColor);
      }

      // Dispatch theme change event for canvas to update drawing color
      document.dispatchEvent(new CustomEvent('themeChanged'));
    }

    function initSystemTheme(defaultTheme = 'light') {
      const savedTheme = localStorage.getItem('pad-theme');
      if (savedTheme) {
        applyTheme({ flavor: 'vanilla', theme: savedTheme });
      } else {
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        applyTheme({ flavor: 'vanilla', theme: prefersDark ? 'dark' : defaultTheme });
      }
    }

    function updateThemeToggleButton() {
      const themeIcon = document.getElementById('themeIcon');
      const themeButton = document.getElementById('themeToggle');
      const isDark = document.documentElement.classList.contains('theme-dark');

      if (themeIcon) {
        themeIcon.setAttribute('name', isDark ? 'bedtime_off' : 'bedtime');
      }
      if (themeButton) {
        themeButton.setAttribute('aria-label', isDark ? 'Switch to light mode' : 'Switch to dark mode');
      }
    }

    function toggleTheme() {
      const isDark = document.documentElement.classList.contains('theme-dark');
      applyTheme({ flavor: 'vanilla', theme: isDark ? 'light' : 'dark' });
      updateThemeToggleButton();
    }

    // Initialize theme system
    initSystemTheme();

    class PadDrawing {
      constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.isDrawing = false;
        this.lastPoint = { x: 0, y: 0 };
        this.currentStroke = [];
        this.strokes = [];

        this.setupCanvas();
        this.setupEventListeners();

        // Restore drawing after a brief delay to ensure canvas is properly sized
        setTimeout(() => this.restoreDrawing(), 100);
      }

      setupCanvas() {
        // Set canvas size to match screen
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // Configure drawing context
        this.updateDrawingStyle();

        // Listen for theme changes to update drawing color
        document.addEventListener('themeChanged', () => this.updateDrawingStyle());
      }

      updateDrawingStyle() {
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-on-background').trim() || '#372116';
      }

      redrawAllStrokes() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // Redraw all strokes with current color
        const color = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-on-background').trim() || '#372116';
        for (const stroke of this.strokes) {
          if (stroke.length < 1) continue;
          this.ctx.beginPath();
          this.ctx.strokeStyle = color;
          this.ctx.moveTo(stroke[0].x, stroke[0].y);
          for (let i = 1; i < stroke.length; i++) {
            const prev = stroke[i - 1];
            const pt = stroke[i];
            const mid = { x: (prev.x + pt.x) / 2, y: (prev.y + pt.y) / 2 };
            this.ctx.lineWidth = 2 + (pt.force * (8 - 2));
            this.ctx.quadraticCurveTo(prev.x, prev.y, mid.x, mid.y);
          }
          this.ctx.stroke();
        }
      }

      resizeCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        // Set actual size in memory (scaled up for high DPI)
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        // Scale the drawing context to match device pixel ratio
        this.ctx.scale(dpr, dpr);

        // Set display size (CSS pixels)
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';

        // Reconfigure context after resize
        this.updateDrawingStyle();
      }

      setupEventListeners() {
        // Clear button functionality
        const clearButton = document.getElementById('clearButton');
        clearButton.addEventListener('click', () => this.clearCanvas());

        // Touch events (includes Apple Pencil)
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

        // Pointer events (fallback for other stylus/mouse)
        this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
        this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
        this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));

        // Prevent default behaviors
        this.canvas.addEventListener('touchstart', (e) => e.preventDefault());
        this.canvas.addEventListener('touchmove', (e) => e.preventDefault());
      }

      getPointFromEvent(e) {
        const rect = this.canvas.getBoundingClientRect();
        let clientX, clientY, force = 0.5, touchType = 'touch';

        if (e.touches && e.touches.length > 0) {
          // Touch event
          const touch = e.touches[0];
          clientX = touch.clientX;
          clientY = touch.clientY;
          force = touch.force || 0.5;
          touchType = touch.touchType || 'touch'; // 'stylus' for Apple Pencil
        } else {
          // Pointer event
          clientX = e.clientX;
          clientY = e.clientY;
          force = e.pressure || 0.5;
          touchType = e.pointerType || 'touch';
        }

        return {
          x: clientX - rect.left,
          y: clientY - rect.top,
          force: force,
          touchType: touchType
        };
      }

      startDrawing(point) {
        this.isDrawing = true;
        this.lastPoint = point;
        this.currentStroke = [point];

        // Start the stroke
        this.ctx.beginPath();
        this.ctx.moveTo(point.x, point.y);
      }

      continueDrawing(point) {
        if (!this.isDrawing) return;

        this.currentStroke.push(point);

        // Calculate line width based on pressure (Apple Pencil support)
        const baseWidth = 2;
        const maxWidth = 8;
        const lineWidth = baseWidth + (point.force * (maxWidth - baseWidth));
        this.ctx.lineWidth = lineWidth;

        // Draw smooth curve to the new point
        if (this.currentStroke.length > 2) {
          // Use quadratic curves for smoother lines
          const prevPoint = this.currentStroke[this.currentStroke.length - 2];
          const midPoint = {
            x: (prevPoint.x + point.x) / 2,
            y: (prevPoint.y + point.y) / 2
          };

          this.ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, midPoint.x, midPoint.y);
        } else {
          this.ctx.lineTo(point.x, point.y);
        }

        this.ctx.stroke();
        this.lastPoint = point;
      }

      endDrawing() {
        if (!this.isDrawing) return;

        this.isDrawing = false;
        if (this.currentStroke.length > 0) {
          this.strokes.push([...this.currentStroke]);
        }
        this.currentStroke = [];

        // Save the drawing after each stroke
        this.saveDrawing();
      }

      clearCanvas() {
        // Show native browser confirmation dialog
        const confirmed = confirm("This will delete everything, are you sure you want to continue?");

        if (confirmed) {
          // Clear the entire canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          // Also clear saved drawing from localStorage
          localStorage.removeItem('padDrawing');
          this.strokes = [];
        }
      }

      // Touch event handlers
      handleTouchStart(e) {
        const point = this.getPointFromEvent(e);
        this.startDrawing(point);
      }

      handleTouchMove(e) {
        const point = this.getPointFromEvent(e);
        this.continueDrawing(point);
      }

      handleTouchEnd(e) {
        this.endDrawing();
      }

      // Pointer event handlers (fallback)
      handlePointerDown(e) {
        // Only handle if no touch events are active
        if (e.pointerType !== 'touch' || !('ontouchstart' in window)) {
          const point = this.getPointFromEvent(e);
          this.startDrawing(point);
        }
      }

      handlePointerMove(e) {
        if (e.pointerType !== 'touch' || !('ontouchstart' in window)) {
          const point = this.getPointFromEvent(e);
          this.continueDrawing(point);
        }
      }

      handlePointerUp(e) {
        if (e.pointerType !== 'touch' || !('ontouchstart' in window)) {
          this.endDrawing();
        }
      }

      // Save and restore drawing functionality
      saveDrawing() {
        try {
          localStorage.setItem('padDrawing', JSON.stringify(this.strokes));
        } catch (e) {
          console.warn('Could not save drawing:', e);
        }
      }

      restoreDrawing() {
        try {
          const saved = localStorage.getItem('padDrawing');
          if (saved) {
            this.strokes = JSON.parse(saved);
            this.redrawAllStrokes();
          }
        } catch (e) {
          this.strokes = [];
          console.warn('Could not restore drawing:', e);
        }
      }
    }

    // Initialize the drawing pad when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      const pad = new PadDrawing();

      // Redraw all strokes on theme change
      document.addEventListener('themeChanged', () => pad.redrawAllStrokes());

      // Setup theme toggle button
      const themeToggle = document.getElementById('themeToggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', toggleTheme);
        updateThemeToggleButton();
      }
    });
  </script>
</body>

</html>
