<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pad V0</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#FBFBFD">
  <link rel="stylesheet" href="../../design-system/src/styles/main.css">
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--color-surface, #FBFBFD);
      color: var(--color-on-surface, #372116);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .pad-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .pad-header {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
      font-size: 14px;
      font-weight: 500;
      color: var(--color-on-surface, #372116);
      opacity: 0.6;
    }

    .pad-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      touch-action: none;
      /* Prevent scrolling/zooming */
    }

    /* Ensure canvas fills entire screen */
    .pad-canvas {
      display: block;
    }

    /* Add some subtle visual feedback */
    .pad-canvas:active {
      cursor: none;
      /* Hide cursor while drawing */
    }

    /* Loading state for better UX */
    .pad-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--color-on-surface, #372116);
      opacity: 0.5;
      font-size: 16px;
      display: none;
    }
  </style>
</head>

<body>
  <div class="pad-container">
    <div class="pad-header">Pad V0</div>
    <canvas id="drawingCanvas" class="pad-canvas" width="1024" height="768"></canvas>
  </div>

  <script>
    class PadDrawing {
      constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.isDrawing = false;
        this.lastPoint = { x: 0, y: 0 };
        this.currentStroke = [];

        this.setupCanvas();
        this.setupEventListeners();
      }

      setupCanvas() {
        // Set canvas size to match screen
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // Configure drawing context
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-on-surface').trim() || '#372116';
      }

      resizeCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        // Set actual size in memory (scaled up for high DPI)
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        // Scale the drawing context to match device pixel ratio
        this.ctx.scale(dpr, dpr);

        // Set display size (CSS pixels)
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';

        // Reconfigure context after resize
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-on-surface').trim() || '#372116';
      }

      setupEventListeners() {
        // Touch events (includes Apple Pencil)
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

        // Pointer events (fallback for other stylus/mouse)
        this.canvas.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
        this.canvas.addEventListener('pointermove', (e) => this.handlePointerMove(e));
        this.canvas.addEventListener('pointerup', (e) => this.handlePointerUp(e));

        // Prevent default behaviors
        this.canvas.addEventListener('touchstart', (e) => e.preventDefault());
        this.canvas.addEventListener('touchmove', (e) => e.preventDefault());
      }

      getPointFromEvent(e) {
        const rect = this.canvas.getBoundingClientRect();
        let clientX, clientY, force = 0.5, touchType = 'touch';

        if (e.touches && e.touches.length > 0) {
          // Touch event
          const touch = e.touches[0];
          clientX = touch.clientX;
          clientY = touch.clientY;
          force = touch.force || 0.5;
          touchType = touch.touchType || 'touch'; // 'stylus' for Apple Pencil
        } else {
          // Pointer event
          clientX = e.clientX;
          clientY = e.clientY;
          force = e.pressure || 0.5;
          touchType = e.pointerType || 'touch';
        }

        return {
          x: clientX - rect.left,
          y: clientY - rect.top,
          force: force,
          touchType: touchType
        };
      }

      startDrawing(point) {
        this.isDrawing = true;
        this.lastPoint = point;
        this.currentStroke = [point];

        // Start the stroke
        this.ctx.beginPath();
        this.ctx.moveTo(point.x, point.y);
      }

      continueDrawing(point) {
        if (!this.isDrawing) return;

        this.currentStroke.push(point);

        // Calculate line width based on pressure (Apple Pencil support)
        const baseWidth = 2;
        const maxWidth = 8;
        const lineWidth = baseWidth + (point.force * (maxWidth - baseWidth));
        this.ctx.lineWidth = lineWidth;

        // Draw smooth curve to the new point
        if (this.currentStroke.length > 2) {
          // Use quadratic curves for smoother lines
          const prevPoint = this.currentStroke[this.currentStroke.length - 2];
          const midPoint = {
            x: (prevPoint.x + point.x) / 2,
            y: (prevPoint.y + point.y) / 2
          };

          this.ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, midPoint.x, midPoint.y);
        } else {
          this.ctx.lineTo(point.x, point.y);
        }

        this.ctx.stroke();
        this.lastPoint = point;
      }

      endDrawing() {
        if (!this.isDrawing) return;

        this.isDrawing = false;
        this.currentStroke = [];
      }

      // Touch event handlers
      handleTouchStart(e) {
        const point = this.getPointFromEvent(e);
        this.startDrawing(point);
      }

      handleTouchMove(e) {
        const point = this.getPointFromEvent(e);
        this.continueDrawing(point);
      }

      handleTouchEnd(e) {
        this.endDrawing();
      }

      // Pointer event handlers (fallback)
      handlePointerDown(e) {
        // Only handle if no touch events are active
        if (e.pointerType !== 'touch' || !('ontouchstart' in window)) {
          const point = this.getPointFromEvent(e);
          this.startDrawing(point);
        }
      }

      handlePointerMove(e) {
        if (e.pointerType !== 'touch' || !('ontouchstart' in window)) {
          const point = this.getPointFromEvent(e);
          this.continueDrawing(point);
        }
      }

      handlePointerUp(e) {
        if (e.pointerType !== 'touch' || !('ontouchstart' in window)) {
          this.endDrawing();
        }
      }
    }

    // Initialize the drawing pad when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      new PadDrawing();
    });
  </script>
</body>

</html>
